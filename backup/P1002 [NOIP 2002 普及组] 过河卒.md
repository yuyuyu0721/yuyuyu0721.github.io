# P1002 [NOIP 2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，A 点 $(0, 0)$、B 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 输入格式

一行四个正整数，分别表示 $B$ 点坐标和马的坐标。

## 输出格式

一个整数，表示所有的路径条数。

## 输入输出样例 #1

### 输入 #1

```
6 6 3 3
```

### 输出 #1

```
6
```

## 说明/提示

对于 100 %的数据，1 <= n, m <= 20，0 <= 马的坐标 <=20


**【题目来源】**

NOIP 2002 普及组第四题

# 题目简述
* 计算出卒从 A 点能够到达 B `n`,`m`点的路径的条数
* 卒只能向下或者向右(且不能走马所在的位置,即禁行点)
* 马`x`,`y`走日字型(且马位置不动)即下图
## 图示

<img width="1737" height="1028" alt="Image" src="https://github.com/user-attachments/assets/55b70c07-f8e2-41fa-aff9-38243cebdcea" />

# 题解
```python
n,m,x,y=map(int,input().split())
horse=[(-2,-1),(-2,1),(-1,2),(-1,-2),(1,2),(1,-2),(2,1),(2,-1)]
dp=[[0]*(m+1) for _ in range(n+1)]
dp[0][0]=1
block=set()
if 0<=x<=n and 0<=y<=m:
    block.add((x, y))
for dx,dy in horse:
    nx=x+dx
    ny=y+dy
    if 0<=nx<=n and 0<=ny<=m:
        block.add((nx, ny))
for i in range(n+1):
    for j in range(m+1):
        if (i,j) in block:
            dp[i][j]=0
            continue
        if i > 0:
            dp[i][j]+=dp[i-1][j]
        if j > 0:
            dp[i][j]+=dp[i][j-1]
print(dp[n][m])
```
# 题目解析

## 整体思路
此题以考动态规划为主
* 大问题:求` (0,0) `到` (n,m) `的路径数
* 子问题:求` (0,0) `到任意位置` (i,j) `的路径数
* 状态转移:到达` (i,j) `的路径数 = 到达上方` (i-1,j) `的路径数 + 到达左方` (i,j-1) `的路径数(因为卒只能从这两个方向来)
* 障碍处理:障碍位置的路径数强制为 0(无法到达 / 通过)

## 输入处理
```python
n,m,x,y=map(int,input().split())
```

B点位置为`(n,m)`,马的位置为`(x,y)`
输入`6 6 3 3`
B(即终点)为`(6,6)`,马为`(3,3)`

## 定义马的跳点
<img width="1737" height="1028" alt="Image" src="https://github.com/user-attachments/assets/55b70c07-f8e2-41fa-aff9-38243cebdcea" />


根据上图可知为
```python
 horse=[(-2,-1),(-2,1),(-1,2),(-1,-2),(1,2),(1,-2),(2,1),(2,-1)]
```

## 初始化列表
```python
dp=[[0]*(m+1) for _ in range(n+1)]
dp[0][0]=1
block=set()
```

 * `dp=[[0]*(m+1) for _ in range(n+1)]`创建一个`(n+1)` 行、`(m+1)` 列的二维列表
 * `dp[0][0]=1`初始化路径为1，为后续的列表填充做先决条件
 * `block=set()`block为空集合为后续添加马的位置做先决条件

## 马的位置判断和标记
```python
if 0<=x<=n and 0<=y<=m:
    block.add((x, y))
for dx,dy in horse:
    nx=x+dx
    ny=y+dy
    if 0<=nx<=n and 0<=ny<=m:
        block.add((nx, ny))
```
* `if 0<=x<=n and 0<=y<=m:`判断马本身是否在表内
>[!TIP]
马本身也是一个禁行点不要忘记
* `block.add((x, y))`判断成功后添加带`block`集合内
### for循环内语块 
* `for dx,dy in horse:`设立两个变量名`dx`,`dy`在`horse`这个列表里面遍历
>[!TIP]
`dx`,`dy`为马的位置再次细分分别代表马的横坐标和纵坐标
* `nx=x+dx`,`ny=y+dy`两者都是更新马的位置,马的走完后位置=马原本的位置+马的跳点
* `if 0<=nx<=n and 0<=ny<=m:`再次判断两者的位置是否超出列表之内
* `block.add((nx, ny))`判断成功后则再将马走完后的位置添加到集合内

## 列表填充
```python
for i in range(n+1):
    for j in range(m+1):
        if (i,j) in block:
            dp[i][j]=0
            continue
        if i > 0:
            dp[i][j]+=dp[i-1][j]
        if j > 0:
            dp[i][j]+=dp[i][j-1]
```
### for循环嵌套
```python
for i in range(n+1):
    for j in range(m+1):
```
* 前者for为遍历行从0到`n`后者则为遍历列从0到`m`
其本质为:按 行优先 遍历,先把第0行的所有列`(j=0→m)`处理完,再处理第1行`(j=0→m)`,直到第 n 行
 
* `if (i,j) in block:`判断当前遍历的棋盘位置 (i, j)(行号为i、列号为j)是否属于'卒无法通过的障碍集合'即`block`（障碍包括马的自身位置、马的 8 个跳跃控制点
* `dp[i][j]=0`若判断成功则将当前强制改为0,即卒无法通过的点
* `continue`并且跳过当前迭代的次数,避免后续的累加
* `if i > 0:`,` if j > 0:`判断是否出界且在第一行/列
* `dp[i][j]+=dp[i-1][j]`,`dp[i][j]+=dp[i][j-1]`若判断成功，则累加上一格的值

## 输出
* `print(dp[n][m])`把此位置(即终点)上的数输出出来就是路径数

#答疑解惑(更详细的说明一些问题)

## 问一:'为什么`dp=[[0]*(m+1) for _ in range(n+1)]`不能换为`dp=[[0]*(n+1) for _ in range(m+1)]`'
* 在本题内此举确实可以输出正确,但是却仍会得不到满分,主要是逻辑问题,以`n=2`,`m=3`举例由3列4行变为4列3行导致后面索引可能出错

## 问二:'为什么用`block=set()`集合来做,用列表不也能照样ac'
* 列表确实能做,是不可否认的,但是集合用来存储障碍更快且更简洁,例如用列表就必须先将马的位置标记为-1后续再做判断落点是否为-1,而集合就不用可以直接用`in`也省略了前面的赋值

# 总结
动态规划也就是此题主要核心其实就是第13行到第21行的填充列表,前面都是在为后面的填充设置禁卒点也就是条件限制
[此题链接](https://www.luogu.com.cn/problem/P1002)
